[
    {
        "id": "24564851294",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1581,
                    "closed_issues": 574,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-13T00:23:14Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 10,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276906922",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276906922,
                "node_id": "IC_kwDODI9FZc5MHA2q",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-13T01:18:55Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "author_association": "NONE",
                "body": "> Random thought (I'm not at PC to test) - maybe a JIT size miscalculation due to the explicit struct layout? (not as random as it sounds - the last time I found a JIT bug was the \"fixed buffers\" size miscalculation)\r\n\r\nIn my experimentation removing explicit layout, or adding kinda random padding, made no difference.  I default to explicit layouts when doing tricky things with structs since I can never remember what's actually guaranteed by the compiler - given how shrunk down this repro is, it could _probably_ be removed safely...",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-13T01:18:55Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24557794744",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1572,
                    "closed_issues": 569,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-12T16:24:28Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 5,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276501007",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276501007,
                "node_id": "IC_kwDODI9FZc5MFdwP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-12T17:21:39Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "author_association": "NONE",
                "body": "@vcsjones still reproduces for me (.NET 7 RC, using POH, x64) with `COMPlus_JITMinOpts=1` - just a couple iterations, though they are slower iterations (as expected).",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T17:21:39Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24553861859",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T14:29:29Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\n\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, grabbing a `ref someByte[0]` local, and punning it via `MemoryMarshal.Cast`\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\n\n### Reproduction Steps\n\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copiedhere:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\nA old colleague had a variant using a `byte[][]` instead, which might be easier to diagnose.  They're also the ones who confirmed the .NET 6 repro.  I'll see if they can't add their findings it to this issue later today.\n\n### Expected behavior\n\nI would expect the attached code to run fine forever.\n\n### Actual behavior\n\nCrashes with some sort of data corruption.\n\n### Regression?\n\nNo, this reproduces (at least in part) on .NET 6.\n\n### Known Workarounds\n\nDon't use the POH I guess?\n\n### Configuration\n\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\n\n### Other information\n\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T14:29:29Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24309726173",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1576303484,
                        "node_id": "MDU6TGFiZWwxNTc2MzAzNDg0",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/enhancement",
                        "name": "enhancement",
                        "color": "200dff",
                        "default": true,
                        "description": "Product code improvement that does NOT require public API changes/additions"
                    },
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1531,
                    "closed_issues": 450,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-09-29T20:24:25Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 20,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1262806164",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1262806164,
                "node_id": "IC_kwDODI9FZc5LROSU",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-29T20:55:15Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "author_association": "NONE",
                "body": "@Maoni0 unfortunately, it doesn't look like we'll be able to try swapping out the GC.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-29T20:55:15Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24251357281",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 15,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1259588239",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1259588239,
                "node_id": "IC_kwDODI9FZc5LE8qP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-27T14:25:31Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "author_association": "NONE",
                "body": "@davidfowl looking at GC handles the most recent crash had 1,790 `AsyncPinned` pins, which should be the upper bound on pending socket reads.  Tricky to say how many of those originate in `SslStream` vs Kestrel vs other app code - and unfortunately it looks like Watson has culled that dump, so all we've got are my notes and I can't go spelunking for more information.\r\n\r\nGoing off of the code, all the `SslStream`'s I've found _should_ be backed by `NetworkStream`s but I cannot prove that from my notes.\r\n\r\n> this is very common with a collection of any generation, not just a full collection.\r\n\r\n@Maoni0 I see, so I conflated \"full\" and \"compacting\" here.  Good to know.\r\n\r\n> this situation will be better with regions. if you are using .net 6.0 already I can give you a clrgc.dll with the 7.0 GC implementation that you can load with an env var with your 6.0 build. are you interested in trying that?\r\n\r\nI don't _think_ we're equipped to exercise that, but I'll double check.  Regardless, if this is less likely in upcoming .NET versions then that is good news.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-27T14:25:31Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24225307920",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 12,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1258088579",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1258088579,
                "node_id": "IC_kwDODI9FZc5K_OiD",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-26T14:01:22Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "author_association": "NONE",
                "body": "@wfurt the size of the buffer isn't a concern, it's that it's used for I/O and thus ends up pinned and prevents full compaction of the heap - grabbing an array from the POH would avoid this.\r\n\r\nI am going to investigate @stephentoub's suggestion as a mitigation for us.  It would be nice if the naive use of `SslStream` was unable to cause this, but I recognize there are tradeoffs to doing so.\r\n\r\n> I'm trying to tease apart the pinning problem (GC not being able to clean these up at all), and the SSLStream pinning problem, which I don't quite understand.\r\n\r\n@davidfowl Let me take another whack at explaining - sorry it's kind of complicated.\r\n\r\nIn our application...\r\n  - We're handling HTTP requests (using Kestrel), this accounts for some POH use.\r\n  - We have a cache that tries to consume a fixed percentage (typically about 50%) of the process's maximum memory, this stuff mostly ends up on the ephemeral segment in generations 1 & 2.\r\n  - Some of the cache, and some other code in the application, can also end up allocating on the LOH.\r\n  - We're communicating with some internal services using a library we don't have full control of, this library is using `SslStream` internally.\r\n     * My understanding of `SslStream` is that, during reads, [`_internalBuffer` is used for I/O](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1129) which pins it temporarily.  Since [`_internalBuffer` is obtained from `ArrayPool<byte>.Shared`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) and < 85,000 bytes it'll end up in the ephemeral heap segment.\r\n  - Importantly, LOH and POH stay pretty small relative to total process memory.  They are in regular use, but at any point in time they are not that _big_ relatively.\r\n     * From an example crash: we had a POH of ~200MB, a LOH of ~800MB, and gens 0 through 2 were 13<b>GB</b>\r\n  - When an OOM is encountered it's because one of the LOH or POH were full, and when the GC did a full collection it was unable to shrink the ephemeral segment sufficiently to grow the needed heap.\r\n     * This means that when we crash the managed is mostly free space, but the LOH or POH is mostly in use.\r\n     * To go back to that crash, what we saw was:\r\n        + Gen0, total size 2,845,667,328, free space 2,842,594,784.\r\n            * The very tail end of Gen0 has one of the arrays from `SslStream` pinned.\r\n            * That Gen0 almost entirely free space hints that the GC recently ran a full collection.\r\n            * That Gen0 ends with a pinned array hints that the GC reclaimed as much of the seme\r\n         + Gen1, total size 53,363,968, free space 112,552.\r\n         + Gen2, total size 10,325,070,552, free space 74,462,096.\r\n            * Most of Gen2 this is our cache.\r\n         + LOH, total size 871,634,968, free space 59,712.\r\n         + POH, total size 227,877,080, free space 5,648.\r\n         + And we crashed when a POH allocation was requested.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-26T14:01:22Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24187282921",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 6,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1256276616",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1256276616,
                "node_id": "IC_kwDODI9FZc5K4UKI",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-23T14:19:10Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "author_association": "NONE",
                "body": "@davidfowl the code using `SslStream` is outside of Kestrel, but we are using Kestrel in the app. In the cases we've seen where the POH is the heap that fails to grow it's Kestrel that's trying to allocate, and Kestrel that's making the most use of the POH.\r\n\r\nWe've seen incidents where it's the LOH that fails to grow, in those cases it's been our own code trying to allocate.\r\n\r\nThis reproduces pretty rarely (on the order of once a month or so, though we're concerned it could happen more frequently under higher load), unfortunately, as it's sensitive to GC and request timing.   It took us a few months to come to this conclusion, in part because we didn't have an easy repro to test hypotheses - as noted in the issue, we ended up using Perfview to find where appropriately sized pins were happening and then interrogating the source.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-23T14:19:11Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24169760430",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 2,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1255373429",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1255373429,
                "node_id": "IC_kwDODI9FZc5K03p1",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-22T18:04:59Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "author_association": "NONE",
                "body": "> There shouldn't be any long-lived pinning happening on other OSes. This is inherent to the Windows model for overlapped I/O, where the buffers are supplied to the receive/read calls performing the I/O; on Linux/macOS/etc., a buffer is only supplied under the covers once the implementation is notified data is available. I realize this isn't the intent of your issue, but if you have evidence of this happening anywhere other than Windows, I'd be interested in seeing it.\r\n\r\nAh, this is good to know - I assumed other OS's were similar, but if that is incorrect then there is no evidence this can happen on other OS's.  I'll update the issue accordingly.\r\n\r\n> Are these SslStreams in your control, or are they underlying a component like HttpClient you don't own? You might try using zero-byte reads, e.g. first perform a read with `ReadOnlySpan/Memory<byte>.Empty`, and then only issue the actual read when you know data is available. That should avoid the pinning.\r\n\r\nTechnically we don't control the underlying component, but enough of the reads are simple passthroughs that this might also be a viable mitigation.  Given the way our app is structure it might be a bit painful to apply to everything that matters, but that's our problem not .NET's.\r\n\r\nJust to be clear, you're suggesting we switch:\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nvar foo = await stream.ReadAsync(mem, token);\r\n// use foo\r\n```\r\n\r\nwith\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nawait stream.ReadAsync(Memory<byte>.Empty, someCancellationToken); \r\nvar foo = await stream.ReadAsync(someMemory, someCancellationToken);\r\n// use foo\r\n```",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T18:04:59Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24168847483",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T17:17:52Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T17:17:52Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "23569388199",
        "type": "ForkEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 156260788,
            "name": "Azure/azure-cosmos-dotnet-v3",
            "url": "https://api.github.com/repos/Azure/azure-cosmos-dotnet-v3"
        },
        "payload": {
            "forkee": {
                "id": 527664030,
                "node_id": "R_kgDOH3ODng",
                "name": "azure-cosmos-dotnet-v3",
                "full_name": "kevin-montrose/azure-cosmos-dotnet-v3",
                "private": false,
                "owner": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "html_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "description": ".NET SDK for Azure Cosmos DB for the core SQL API",
                "fork": true,
                "url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3",
                "forks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/forks",
                "keys_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/keys{/key_id}",
                "collaborators_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/collaborators{/collaborator}",
                "teams_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/teams",
                "hooks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/hooks",
                "issue_events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/events{/number}",
                "events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/events",
                "assignees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/assignees{/user}",
                "branches_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/branches{/branch}",
                "tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/tags",
                "blobs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/blobs{/sha}",
                "git_tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/tags{/sha}",
                "git_refs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/refs{/sha}",
                "trees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/trees{/sha}",
                "statuses_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/statuses/{sha}",
                "languages_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/languages",
                "stargazers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/stargazers",
                "contributors_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contributors",
                "subscribers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscribers",
                "subscription_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscription",
                "commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/commits{/sha}",
                "git_commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/commits{/sha}",
                "comments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/comments{/number}",
                "issue_comment_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/comments{/number}",
                "contents_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contents/{+path}",
                "compare_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/compare/{base}...{head}",
                "merges_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/merges",
                "archive_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/{archive_format}{/ref}",
                "downloads_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/downloads",
                "issues_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues{/number}",
                "pulls_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/pulls{/number}",
                "milestones_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/milestones{/number}",
                "notifications_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/notifications{?since,all,participating}",
                "labels_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/labels{/name}",
                "releases_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/releases{/id}",
                "deployments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/deployments",
                "created_at": "2022-08-22T17:21:38Z",
                "updated_at": "2022-08-22T11:17:41Z",
                "pushed_at": "2022-08-22T11:27:07Z",
                "git_url": "git://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "ssh_url": "git@github.com:kevin-montrose/azure-cosmos-dotnet-v3.git",
                "clone_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "svn_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "homepage": null,
                "size": 147074,
                "stargazers_count": 0,
                "watchers_count": 0,
                "language": null,
                "has_issues": false,
                "has_projects": true,
                "has_downloads": true,
                "has_wiki": true,
                "has_pages": false,
                "forks_count": 0,
                "mirror_url": null,
                "archived": false,
                "disabled": false,
                "open_issues_count": 0,
                "license": null,
                "allow_forking": true,
                "is_template": false,
                "web_commit_signoff_required": false,
                "topics": [],
                "visibility": "public",
                "forks": 0,
                "open_issues": 0,
                "watchers": 0,
                "default_branch": "main",
                "public": true
            }
        },
        "public": true,
        "created_at": "2022-08-22T17:21:38Z",
        "org": {
            "id": 6844498,
            "login": "Azure",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/Azure",
            "avatar_url": "https://avatars.githubusercontent.com/u/6844498?"
        }
    },
    {
        "id": "24564851294",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1581,
                    "closed_issues": 574,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-13T00:23:14Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 10,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276906922",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276906922,
                "node_id": "IC_kwDODI9FZc5MHA2q",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-13T01:18:55Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "author_association": "NONE",
                "body": "> Random thought (I'm not at PC to test) - maybe a JIT size miscalculation due to the explicit struct layout? (not as random as it sounds - the last time I found a JIT bug was the \"fixed buffers\" size miscalculation)\r\n\r\nIn my experimentation removing explicit layout, or adding kinda random padding, made no difference.  I default to explicit layouts when doing tricky things with structs since I can never remember what's actually guaranteed by the compiler - given how shrunk down this repro is, it could _probably_ be removed safely...",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-13T01:18:55Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24557794744",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1572,
                    "closed_issues": 569,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-12T16:24:28Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 5,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276501007",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276501007,
                "node_id": "IC_kwDODI9FZc5MFdwP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-12T17:21:39Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "author_association": "NONE",
                "body": "@vcsjones still reproduces for me (.NET 7 RC, using POH, x64) with `COMPlus_JITMinOpts=1` - just a couple iterations, though they are slower iterations (as expected).",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T17:21:39Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24553861859",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T14:29:29Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\n\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, grabbing a `ref someByte[0]` local, and punning it via `MemoryMarshal.Cast`\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\n\n### Reproduction Steps\n\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copiedhere:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\nA old colleague had a variant using a `byte[][]` instead, which might be easier to diagnose.  They're also the ones who confirmed the .NET 6 repro.  I'll see if they can't add their findings it to this issue later today.\n\n### Expected behavior\n\nI would expect the attached code to run fine forever.\n\n### Actual behavior\n\nCrashes with some sort of data corruption.\n\n### Regression?\n\nNo, this reproduces (at least in part) on .NET 6.\n\n### Known Workarounds\n\nDon't use the POH I guess?\n\n### Configuration\n\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\n\n### Other information\n\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T14:29:29Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24309726173",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1576303484,
                        "node_id": "MDU6TGFiZWwxNTc2MzAzNDg0",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/enhancement",
                        "name": "enhancement",
                        "color": "200dff",
                        "default": true,
                        "description": "Product code improvement that does NOT require public API changes/additions"
                    },
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1531,
                    "closed_issues": 450,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-09-29T20:24:25Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 20,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1262806164",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1262806164,
                "node_id": "IC_kwDODI9FZc5LROSU",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-29T20:55:15Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "author_association": "NONE",
                "body": "@Maoni0 unfortunately, it doesn't look like we'll be able to try swapping out the GC.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-29T20:55:15Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24251357281",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 15,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1259588239",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1259588239,
                "node_id": "IC_kwDODI9FZc5LE8qP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-27T14:25:31Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "author_association": "NONE",
                "body": "@davidfowl looking at GC handles the most recent crash had 1,790 `AsyncPinned` pins, which should be the upper bound on pending socket reads.  Tricky to say how many of those originate in `SslStream` vs Kestrel vs other app code - and unfortunately it looks like Watson has culled that dump, so all we've got are my notes and I can't go spelunking for more information.\r\n\r\nGoing off of the code, all the `SslStream`'s I've found _should_ be backed by `NetworkStream`s but I cannot prove that from my notes.\r\n\r\n> this is very common with a collection of any generation, not just a full collection.\r\n\r\n@Maoni0 I see, so I conflated \"full\" and \"compacting\" here.  Good to know.\r\n\r\n> this situation will be better with regions. if you are using .net 6.0 already I can give you a clrgc.dll with the 7.0 GC implementation that you can load with an env var with your 6.0 build. are you interested in trying that?\r\n\r\nI don't _think_ we're equipped to exercise that, but I'll double check.  Regardless, if this is less likely in upcoming .NET versions then that is good news.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-27T14:25:31Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24225307920",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 12,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1258088579",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1258088579,
                "node_id": "IC_kwDODI9FZc5K_OiD",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-26T14:01:22Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "author_association": "NONE",
                "body": "@wfurt the size of the buffer isn't a concern, it's that it's used for I/O and thus ends up pinned and prevents full compaction of the heap - grabbing an array from the POH would avoid this.\r\n\r\nI am going to investigate @stephentoub's suggestion as a mitigation for us.  It would be nice if the naive use of `SslStream` was unable to cause this, but I recognize there are tradeoffs to doing so.\r\n\r\n> I'm trying to tease apart the pinning problem (GC not being able to clean these up at all), and the SSLStream pinning problem, which I don't quite understand.\r\n\r\n@davidfowl Let me take another whack at explaining - sorry it's kind of complicated.\r\n\r\nIn our application...\r\n  - We're handling HTTP requests (using Kestrel), this accounts for some POH use.\r\n  - We have a cache that tries to consume a fixed percentage (typically about 50%) of the process's maximum memory, this stuff mostly ends up on the ephemeral segment in generations 1 & 2.\r\n  - Some of the cache, and some other code in the application, can also end up allocating on the LOH.\r\n  - We're communicating with some internal services using a library we don't have full control of, this library is using `SslStream` internally.\r\n     * My understanding of `SslStream` is that, during reads, [`_internalBuffer` is used for I/O](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1129) which pins it temporarily.  Since [`_internalBuffer` is obtained from `ArrayPool<byte>.Shared`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) and < 85,000 bytes it'll end up in the ephemeral heap segment.\r\n  - Importantly, LOH and POH stay pretty small relative to total process memory.  They are in regular use, but at any point in time they are not that _big_ relatively.\r\n     * From an example crash: we had a POH of ~200MB, a LOH of ~800MB, and gens 0 through 2 were 13<b>GB</b>\r\n  - When an OOM is encountered it's because one of the LOH or POH were full, and when the GC did a full collection it was unable to shrink the ephemeral segment sufficiently to grow the needed heap.\r\n     * This means that when we crash the managed is mostly free space, but the LOH or POH is mostly in use.\r\n     * To go back to that crash, what we saw was:\r\n        + Gen0, total size 2,845,667,328, free space 2,842,594,784.\r\n            * The very tail end of Gen0 has one of the arrays from `SslStream` pinned.\r\n            * That Gen0 almost entirely free space hints that the GC recently ran a full collection.\r\n            * That Gen0 ends with a pinned array hints that the GC reclaimed as much of the seme\r\n         + Gen1, total size 53,363,968, free space 112,552.\r\n         + Gen2, total size 10,325,070,552, free space 74,462,096.\r\n            * Most of Gen2 this is our cache.\r\n         + LOH, total size 871,634,968, free space 59,712.\r\n         + POH, total size 227,877,080, free space 5,648.\r\n         + And we crashed when a POH allocation was requested.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-26T14:01:22Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24187282921",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 6,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1256276616",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1256276616,
                "node_id": "IC_kwDODI9FZc5K4UKI",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-23T14:19:10Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "author_association": "NONE",
                "body": "@davidfowl the code using `SslStream` is outside of Kestrel, but we are using Kestrel in the app. In the cases we've seen where the POH is the heap that fails to grow it's Kestrel that's trying to allocate, and Kestrel that's making the most use of the POH.\r\n\r\nWe've seen incidents where it's the LOH that fails to grow, in those cases it's been our own code trying to allocate.\r\n\r\nThis reproduces pretty rarely (on the order of once a month or so, though we're concerned it could happen more frequently under higher load), unfortunately, as it's sensitive to GC and request timing.   It took us a few months to come to this conclusion, in part because we didn't have an easy repro to test hypotheses - as noted in the issue, we ended up using Perfview to find where appropriately sized pins were happening and then interrogating the source.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-23T14:19:11Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24169760430",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 2,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1255373429",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1255373429,
                "node_id": "IC_kwDODI9FZc5K03p1",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-22T18:04:59Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "author_association": "NONE",
                "body": "> There shouldn't be any long-lived pinning happening on other OSes. This is inherent to the Windows model for overlapped I/O, where the buffers are supplied to the receive/read calls performing the I/O; on Linux/macOS/etc., a buffer is only supplied under the covers once the implementation is notified data is available. I realize this isn't the intent of your issue, but if you have evidence of this happening anywhere other than Windows, I'd be interested in seeing it.\r\n\r\nAh, this is good to know - I assumed other OS's were similar, but if that is incorrect then there is no evidence this can happen on other OS's.  I'll update the issue accordingly.\r\n\r\n> Are these SslStreams in your control, or are they underlying a component like HttpClient you don't own? You might try using zero-byte reads, e.g. first perform a read with `ReadOnlySpan/Memory<byte>.Empty`, and then only issue the actual read when you know data is available. That should avoid the pinning.\r\n\r\nTechnically we don't control the underlying component, but enough of the reads are simple passthroughs that this might also be a viable mitigation.  Given the way our app is structure it might be a bit painful to apply to everything that matters, but that's our problem not .NET's.\r\n\r\nJust to be clear, you're suggesting we switch:\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nvar foo = await stream.ReadAsync(mem, token);\r\n// use foo\r\n```\r\n\r\nwith\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nawait stream.ReadAsync(Memory<byte>.Empty, someCancellationToken); \r\nvar foo = await stream.ReadAsync(someMemory, someCancellationToken);\r\n// use foo\r\n```",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T18:04:59Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24168847483",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T17:17:52Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T17:17:52Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "23569388199",
        "type": "ForkEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 156260788,
            "name": "Azure/azure-cosmos-dotnet-v3",
            "url": "https://api.github.com/repos/Azure/azure-cosmos-dotnet-v3"
        },
        "payload": {
            "forkee": {
                "id": 527664030,
                "node_id": "R_kgDOH3ODng",
                "name": "azure-cosmos-dotnet-v3",
                "full_name": "kevin-montrose/azure-cosmos-dotnet-v3",
                "private": false,
                "owner": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "html_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "description": ".NET SDK for Azure Cosmos DB for the core SQL API",
                "fork": true,
                "url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3",
                "forks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/forks",
                "keys_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/keys{/key_id}",
                "collaborators_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/collaborators{/collaborator}",
                "teams_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/teams",
                "hooks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/hooks",
                "issue_events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/events{/number}",
                "events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/events",
                "assignees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/assignees{/user}",
                "branches_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/branches{/branch}",
                "tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/tags",
                "blobs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/blobs{/sha}",
                "git_tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/tags{/sha}",
                "git_refs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/refs{/sha}",
                "trees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/trees{/sha}",
                "statuses_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/statuses/{sha}",
                "languages_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/languages",
                "stargazers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/stargazers",
                "contributors_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contributors",
                "subscribers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscribers",
                "subscription_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscription",
                "commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/commits{/sha}",
                "git_commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/commits{/sha}",
                "comments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/comments{/number}",
                "issue_comment_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/comments{/number}",
                "contents_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contents/{+path}",
                "compare_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/compare/{base}...{head}",
                "merges_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/merges",
                "archive_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/{archive_format}{/ref}",
                "downloads_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/downloads",
                "issues_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues{/number}",
                "pulls_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/pulls{/number}",
                "milestones_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/milestones{/number}",
                "notifications_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/notifications{?since,all,participating}",
                "labels_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/labels{/name}",
                "releases_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/releases{/id}",
                "deployments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/deployments",
                "created_at": "2022-08-22T17:21:38Z",
                "updated_at": "2022-08-22T11:17:41Z",
                "pushed_at": "2022-08-22T11:27:07Z",
                "git_url": "git://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "ssh_url": "git@github.com:kevin-montrose/azure-cosmos-dotnet-v3.git",
                "clone_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "svn_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "homepage": null,
                "size": 147074,
                "stargazers_count": 0,
                "watchers_count": 0,
                "language": null,
                "has_issues": false,
                "has_projects": true,
                "has_downloads": true,
                "has_wiki": true,
                "has_pages": false,
                "forks_count": 0,
                "mirror_url": null,
                "archived": false,
                "disabled": false,
                "open_issues_count": 0,
                "license": null,
                "allow_forking": true,
                "is_template": false,
                "web_commit_signoff_required": false,
                "topics": [],
                "visibility": "public",
                "forks": 0,
                "open_issues": 0,
                "watchers": 0,
                "default_branch": "main",
                "public": true
            }
        },
        "public": true,
        "created_at": "2022-08-22T17:21:38Z",
        "org": {
            "id": 6844498,
            "login": "Azure",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/Azure",
            "avatar_url": "https://avatars.githubusercontent.com/u/6844498?"
        }
    },
    {
        "id": "24564851294",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1581,
                    "closed_issues": 574,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-13T00:23:14Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 10,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276906922",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276906922,
                "node_id": "IC_kwDODI9FZc5MHA2q",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-13T01:18:55Z",
                "updated_at": "2022-10-13T01:18:55Z",
                "author_association": "NONE",
                "body": "> Random thought (I'm not at PC to test) - maybe a JIT size miscalculation due to the explicit struct layout? (not as random as it sounds - the last time I found a JIT bug was the \"fixed buffers\" size miscalculation)\r\n\r\nIn my experimentation removing explicit layout, or adding kinda random padding, made no difference.  I default to explicit layouts when doing tricky things with structs since I can never remember what's actually guaranteed by the compiler - given how shrunk down this repro is, it could _probably_ be removed safely...",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276906922/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-13T01:18:55Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24557794744",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386389,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2Mzg5",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-GC-coreclr",
                        "name": "area-GC-coreclr",
                        "color": "d4c5f9",
                        "default": false,
                        "description": ""
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": {
                    "login": "cshung",
                    "id": 3410332,
                    "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/cshung",
                    "html_url": "https://github.com/cshung",
                    "followers_url": "https://api.github.com/users/cshung/followers",
                    "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                    "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                    "organizations_url": "https://api.github.com/users/cshung/orgs",
                    "repos_url": "https://api.github.com/users/cshung/repos",
                    "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/cshung/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "assignees": [
                    {
                        "login": "cshung",
                        "id": 3410332,
                        "node_id": "MDQ6VXNlcjM0MTAzMzI=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/3410332?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/cshung",
                        "html_url": "https://github.com/cshung",
                        "followers_url": "https://api.github.com/users/cshung/followers",
                        "following_url": "https://api.github.com/users/cshung/following{/other_user}",
                        "gists_url": "https://api.github.com/users/cshung/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/cshung/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/cshung/subscriptions",
                        "organizations_url": "https://api.github.com/users/cshung/orgs",
                        "repos_url": "https://api.github.com/users/cshung/repos",
                        "events_url": "https://api.github.com/users/cshung/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/cshung/received_events",
                        "type": "User",
                        "site_admin": false
                    }
                ],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1572,
                    "closed_issues": 569,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-10-12T16:24:28Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 5,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, and punning it via `MemoryMarshal.Cast`\r\n   * An earlier version used a `ref byte` and some unsafe code, but I've removed the unsafe code to eliminate it as a possible cause\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\r\n\r\n### Reproduction Steps\r\n\r\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copied here:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\n### Expected behavior\r\n\r\nI would expect the attached code to run fine forever.\r\n\r\n### Actual behavior\r\n\r\nCrashes with some sort of data corruption.\r\n\r\n### Regression?\r\n\r\nNo, this reproduces (at least in part) on .NET 6.\r\n\r\n### Known Workarounds\r\n\r\nDon't use the POH I guess?\r\n\r\n### Configuration\r\n\r\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\r\n\r\n### Other information\r\n\r\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007",
                "html_url": "https://github.com/dotnet/runtime/issues/76929#issuecomment-1276501007",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "id": 1276501007,
                "node_id": "IC_kwDODI9FZc5MFdwP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-10-12T17:21:39Z",
                "updated_at": "2022-10-12T17:21:39Z",
                "author_association": "NONE",
                "body": "@vcsjones still reproduces for me (.NET 7 RC, using POH, x64) with `COMPlus_JITMinOpts=1` - just a couple iterations, though they are slower iterations (as expected).",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1276501007/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T17:21:39Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24553861859",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76929",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76929",
                "id": 1406318978,
                "node_id": "I_kwDODI9FZc5T0rmC",
                "number": 76929,
                "title": "Data Corruption With Ref Locals, Punning, and Pinned Object Heap",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-10-12T14:29:29Z",
                "updated_at": "2022-10-12T14:29:29Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\n\nThis was a bear to diagnose, and I'm still not 100% on what exactly is happening but the scenario is:\r\n - Have a bunch of `byte[]` s allocated on the POH\r\n - Those `byte[]`s are referenced by a `ConcurrentDictionary`\r\n - Have a bunch of threads getting those `byte[]`s, grabbing a `ref someByte[0]` local, and punning it via `MemoryMarshal.Cast`\r\n - Have some other threads removing `byte[]`s from the `ConcurrentDictionary`\r\n - After some time, data corruption occurs\r\n\r\nI first discovered this as random looking pointers getting written into those `byte[]` arrays, but in the process of winnowing down to a smaller reproduction null reference exceptions, seg faults, and other \"you've corrupted the process\"-style errors became more likely.  I interpret this as the same corruption happening, but because my punned arrays are smaller the corruption is more likely to hit something else.\r\n\r\nI first noticed this in .NET 7 RC (`7.0.0-rc.1.22427.1` specifically) but it has also been reproduced in .NET 6.\n\n### Reproduction Steps\n\nI have [a gist I used to winnow down the repro some](https://gist.github.com/kevin-montrose/90adb1e9e70391f0161b8128b600edff).\r\n\r\nLatest is copiedhere:\r\n\r\n```csharp\r\n\r\n// drop this into a test project\r\n\r\n[StructLayout(LayoutKind.Explicit, Size = Size)]\r\nprivate struct Punned\r\n{\r\n    internal const int Size = 8;\r\n\r\n    [FieldOffset(0)]\r\n    public ulong A;\r\n}\r\n\r\n/// <summary>\r\n/// This spawns a bunch of threads, half of which do integrity checks on a punned byte[]\r\n/// and half of which randomly replace a referenced byte[].\r\n/// \r\n/// Sometimes things just break: either field corruption, null ref, or access violation.\r\n/// \r\n/// Reproduces in DEBUG builds and RELEASE builds.\r\n/// \r\n/// Tends to take < 10 iterations, but not more than 100.  You know, on my machine.\r\n/// \r\n/// Only reproduces if you use the POH, SOH and LOH are fine.\r\n/// </summary>\r\n[Fact]\r\npublic void Repro()\r\n{\r\n    // DOES repro with ALLOC_SIZE >= Punned.Size\r\n    //        and with USE_POH == true\r\n    //\r\n    // does not repro if USE_POH == false\r\n\r\n    // tweak these to mess with alignment and heap\r\n    const int ALLOC_SIZE = Punned.Size;\r\n    const bool USE_POH = true;\r\n\r\n    Assert.True(Punned.Size == Unsafe.SizeOf<Punned>(), \"Hey, this isn't right\");\r\n    Assert.True(ALLOC_SIZE >= Punned.Size, \"Hey, this isn't right\");\r\n\r\n    const int MAX_KEY = 1_000_000;\r\n\r\n    var iter = 0;\r\n    while (true)\r\n    {\r\n        Debug.WriteLine($\"Iteration: {iter}\");\r\n        iter++;\r\n\r\n        var dict = new ConcurrentDictionary<int, byte[]>();\r\n\r\n        // allocate\r\n        for (var i = 0; i < MAX_KEY; i++)\r\n        {\r\n            dict[i] = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n        }\r\n\r\n        // start all the threads\r\n        using var startThreads = new SemaphoreSlim(0, Environment.ProcessorCount);\r\n\r\n        var modifyThreads = new Thread[Environment.ProcessorCount / 2];\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i] = ModifyingThread(i, startThreads, dict);\r\n        }\r\n\r\n        var checkThreads = new Thread[Environment.ProcessorCount - modifyThreads.Length];\r\n        using var stopCheckThreads = new SemaphoreSlim(0, checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i] = IntegrityThread(i, MAX_KEY / checkThreads.Length, startThreads, stopCheckThreads, dict);\r\n        }\r\n\r\n        // let 'em go\r\n        startThreads.Release(modifyThreads.Length + checkThreads.Length);\r\n\r\n        // wait for modifying threads to finish...\r\n        for (var i = 0; i < modifyThreads.Length; i++)\r\n        {\r\n            modifyThreads[i].Join();\r\n        }\r\n\r\n        // stop check threads..\r\n        stopCheckThreads.Release(checkThreads.Length);\r\n        for (var i = 0; i < checkThreads.Length; i++)\r\n        {\r\n            checkThreads[i].Join();\r\n        }\r\n    }\r\n\r\n    static Thread IntegrityThread(\r\n        int threadIx,\r\n        int step,\r\n        SemaphoreSlim startThreads,\r\n        SemaphoreSlim stopThreads,\r\n        ConcurrentDictionary<int, byte[]> dict\r\n    )\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t =\r\n            new Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    startThreads.Wait();\r\n\r\n                    while (!stopThreads.Wait(0))\r\n                    {\r\n                        for (var i = 0; i < MAX_KEY; i++)\r\n                        {\r\n                            var keyIx = (threadIx * step + i) % MAX_KEY;\r\n\r\n                            ref Punned punned = ref Pun(dict[keyIx]);\r\n\r\n                            Check(ref punned);\r\n                        }\r\n                    }\r\n                }\r\n             );\r\n        t.Name = $\"{nameof(Repro)} Integrity #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static Thread ModifyingThread(int threadIx, SemaphoreSlim startThreads, ConcurrentDictionary<int, byte[]> dict)\r\n    {\r\n        using var threadStarted = new SemaphoreSlim(0, 1);\r\n\r\n        var t = new\r\n            Thread(\r\n                () =>\r\n                {\r\n                    threadStarted.Release();\r\n\r\n                    var rand = new Random(threadIx);\r\n\r\n                    startThreads.Wait();\r\n\r\n                    for (var i = 0; i < 1_000_000; i++)\r\n                    {\r\n                        var keyIx = rand.Next(MAX_KEY);\r\n\r\n                        var newArr = GC.AllocateArray<byte>(Punned.Size, pinned: USE_POH);\r\n                        Assert.True(newArr.All(x => x == 0));\r\n\r\n                        // make sure it comes up reasonable\r\n                        ref Punned punned = ref Pun(newArr);\r\n                        Assert.Equal(0UL, punned.A);\r\n\r\n                        // this swaps out the only reference to a byte[]\r\n                        // EXCEPT for any of the checking threads, which only\r\n                        // grab it through a ref\r\n                        dict.AddOrUpdate(keyIx, static (_, passed) => passed, static (_, _, passed) => passed, newArr);\r\n                    }\r\n                }\r\n            );\r\n        t.Name = $\"{nameof(Repro)} Modify #{threadIx}\";\r\n        t.Start();\r\n\r\n        threadStarted.Wait();\r\n\r\n        return t;\r\n    }\r\n\r\n    static ref Punned Pun(byte[] data)\r\n    {\r\n        var span = data.AsSpan();\r\n\r\n        var punned = MemoryMarshal.Cast<byte, Punned>(span);\r\n\r\n        return ref punned[0];\r\n    }\r\n\r\n    static void Check(ref Punned val)\r\n    {\r\n        // all possible bit patterns are well known\r\n        var a = val.A;\r\n        Assert.True(a == 0);\r\n    }\r\n}\r\n```\r\n\r\nThis will fail either in `Check`, with a null ref in an impossible place (usually `AddOrUpdate`), or with some variant of \"runtime has become corrupt\".  The NRE is most common with the above, but earlier revisions usually failed in `Check`.\r\n\r\nIn my testing this only happens if the POH is used (toggle `USE_POH` to verify), and at all (legal) sizes for the `byte[]`s (change `ALLOC_SIZE` to verify).\r\n\r\nA old colleague had a variant using a `byte[][]` instead, which might be easier to diagnose.  They're also the ones who confirmed the .NET 6 repro.  I'll see if they can't add their findings it to this issue later today.\n\n### Expected behavior\n\nI would expect the attached code to run fine forever.\n\n### Actual behavior\n\nCrashes with some sort of data corruption.\n\n### Regression?\n\nNo, this reproduces (at least in part) on .NET 6.\n\n### Known Workarounds\n\nDon't use the POH I guess?\n\n### Configuration\n\nThis was first noticed on:\r\n - Microsoft Windows 11 Home Insider Preview: 10.0.25151 N/A Build 25151\r\n - AMD64 Family 23 Model 96 Stepping 1 AuthenticAMD ~2000 Mhz:  AMD Ryzen\u2122 7 4980U\r\n - .NET 7: Microsoft.WindowsDesktop.App 7.0.0-rc.1.22427.1\r\n\r\nIt is also reproducing, at least in part, on .NET 6.\r\n\r\nIt has been reproduced on a colleagues machine as well, but I don't have the specifics beyond also x64, Windows, and .NET 7 & 6.\n\n### Other information\n\nWhen I've found a corrupted `byte[]` (instead of a NRE or other crash), it looks very pointer-y but seems to point to memory outside of any heap.\r\n\r\nThis makes me think some sort of GC bug, perhaps as part of growing or shrinking the POH, but that is ~98% guesswork.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76929/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76929/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-10-12T14:29:29Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24309726173",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1576303484,
                        "node_id": "MDU6TGFiZWwxNTc2MzAzNDg0",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/enhancement",
                        "name": "enhancement",
                        "color": "200dff",
                        "default": true,
                        "description": "Product code improvement that does NOT require public API changes/additions"
                    },
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": {
                    "url": "https://api.github.com/repos/dotnet/runtime/milestones/99",
                    "html_url": "https://github.com/dotnet/runtime/milestone/99",
                    "labels_url": "https://api.github.com/repos/dotnet/runtime/milestones/99/labels",
                    "id": 8011031,
                    "node_id": "MI_kwDODI9FZc4Aej0X",
                    "number": 99,
                    "title": "8.0.0",
                    "description": "Note: Issues from Future will not be moved here en masse until September 2022.\r\n\r\nPreview, Release Candidates (RC), and General Availability (GA) releases for .NET 8",
                    "creator": {
                        "login": "jeffhandley",
                        "id": 1031940,
                        "node_id": "MDQ6VXNlcjEwMzE5NDA=",
                        "avatar_url": "https://avatars.githubusercontent.com/u/1031940?v=4",
                        "gravatar_id": "",
                        "url": "https://api.github.com/users/jeffhandley",
                        "html_url": "https://github.com/jeffhandley",
                        "followers_url": "https://api.github.com/users/jeffhandley/followers",
                        "following_url": "https://api.github.com/users/jeffhandley/following{/other_user}",
                        "gists_url": "https://api.github.com/users/jeffhandley/gists{/gist_id}",
                        "starred_url": "https://api.github.com/users/jeffhandley/starred{/owner}{/repo}",
                        "subscriptions_url": "https://api.github.com/users/jeffhandley/subscriptions",
                        "organizations_url": "https://api.github.com/users/jeffhandley/orgs",
                        "repos_url": "https://api.github.com/users/jeffhandley/repos",
                        "events_url": "https://api.github.com/users/jeffhandley/events{/privacy}",
                        "received_events_url": "https://api.github.com/users/jeffhandley/received_events",
                        "type": "User",
                        "site_admin": false
                    },
                    "open_issues": 1531,
                    "closed_issues": 450,
                    "state": "open",
                    "created_at": "2022-05-23T16:29:48Z",
                    "updated_at": "2022-09-29T20:24:25Z",
                    "due_on": "2023-11-10T08:00:00Z",
                    "closed_at": null
                },
                "comments": 20,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1262806164",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1262806164,
                "node_id": "IC_kwDODI9FZc5LROSU",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-29T20:55:15Z",
                "updated_at": "2022-09-29T20:55:15Z",
                "author_association": "NONE",
                "body": "@Maoni0 unfortunately, it doesn't look like we'll be able to try swapping out the GC.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1262806164/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-29T20:55:15Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24251357281",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 15,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1259588239",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1259588239,
                "node_id": "IC_kwDODI9FZc5LE8qP",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-27T14:25:31Z",
                "updated_at": "2022-09-27T14:25:31Z",
                "author_association": "NONE",
                "body": "@davidfowl looking at GC handles the most recent crash had 1,790 `AsyncPinned` pins, which should be the upper bound on pending socket reads.  Tricky to say how many of those originate in `SslStream` vs Kestrel vs other app code - and unfortunately it looks like Watson has culled that dump, so all we've got are my notes and I can't go spelunking for more information.\r\n\r\nGoing off of the code, all the `SslStream`'s I've found _should_ be backed by `NetworkStream`s but I cannot prove that from my notes.\r\n\r\n> this is very common with a collection of any generation, not just a full collection.\r\n\r\n@Maoni0 I see, so I conflated \"full\" and \"compacting\" here.  Good to know.\r\n\r\n> this situation will be better with regions. if you are using .net 6.0 already I can give you a clrgc.dll with the 7.0 GC implementation that you can load with an env var with your 6.0 build. are you interested in trying that?\r\n\r\nI don't _think_ we're equipped to exercise that, but I'll double check.  Regardless, if this is less likely in upcoming .NET versions then that is good news.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1259588239/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-27T14:25:31Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24225307920",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 12,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1258088579",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1258088579,
                "node_id": "IC_kwDODI9FZc5K_OiD",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-26T14:01:22Z",
                "updated_at": "2022-09-26T14:01:22Z",
                "author_association": "NONE",
                "body": "@wfurt the size of the buffer isn't a concern, it's that it's used for I/O and thus ends up pinned and prevents full compaction of the heap - grabbing an array from the POH would avoid this.\r\n\r\nI am going to investigate @stephentoub's suggestion as a mitigation for us.  It would be nice if the naive use of `SslStream` was unable to cause this, but I recognize there are tradeoffs to doing so.\r\n\r\n> I'm trying to tease apart the pinning problem (GC not being able to clean these up at all), and the SSLStream pinning problem, which I don't quite understand.\r\n\r\n@davidfowl Let me take another whack at explaining - sorry it's kind of complicated.\r\n\r\nIn our application...\r\n  - We're handling HTTP requests (using Kestrel), this accounts for some POH use.\r\n  - We have a cache that tries to consume a fixed percentage (typically about 50%) of the process's maximum memory, this stuff mostly ends up on the ephemeral segment in generations 1 & 2.\r\n  - Some of the cache, and some other code in the application, can also end up allocating on the LOH.\r\n  - We're communicating with some internal services using a library we don't have full control of, this library is using `SslStream` internally.\r\n     * My understanding of `SslStream` is that, during reads, [`_internalBuffer` is used for I/O](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1129) which pins it temporarily.  Since [`_internalBuffer` is obtained from `ArrayPool<byte>.Shared`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) and < 85,000 bytes it'll end up in the ephemeral heap segment.\r\n  - Importantly, LOH and POH stay pretty small relative to total process memory.  They are in regular use, but at any point in time they are not that _big_ relatively.\r\n     * From an example crash: we had a POH of ~200MB, a LOH of ~800MB, and gens 0 through 2 were 13<b>GB</b>\r\n  - When an OOM is encountered it's because one of the LOH or POH were full, and when the GC did a full collection it was unable to shrink the ephemeral segment sufficiently to grow the needed heap.\r\n     * This means that when we crash the managed is mostly free space, but the LOH or POH is mostly in use.\r\n     * To go back to that crash, what we saw was:\r\n        + Gen0, total size 2,845,667,328, free space 2,842,594,784.\r\n            * The very tail end of Gen0 has one of the arrays from `SslStream` pinned.\r\n            * That Gen0 almost entirely free space hints that the GC recently ran a full collection.\r\n            * That Gen0 ends with a pinned array hints that the GC reclaimed as much of the seme\r\n         + Gen1, total size 53,363,968, free space 112,552.\r\n         + Gen2, total size 10,325,070,552, free space 74,462,096.\r\n            * Most of Gen2 this is our cache.\r\n         + LOH, total size 871,634,968, free space 59,712.\r\n         + POH, total size 227,877,080, free space 5,648.\r\n         + And we crashed when a POH allocation was requested.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1258088579/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-26T14:01:22Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24187282921",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 6,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible <strike>under all OS</strike> (_per discussion below, this is Windows specific_) on Windows for all hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1256276616",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1256276616,
                "node_id": "IC_kwDODI9FZc5K4UKI",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-23T14:19:10Z",
                "updated_at": "2022-09-23T14:19:10Z",
                "author_association": "NONE",
                "body": "@davidfowl the code using `SslStream` is outside of Kestrel, but we are using Kestrel in the app. In the cases we've seen where the POH is the heap that fails to grow it's Kestrel that's trying to allocate, and Kestrel that's making the most use of the POH.\r\n\r\nWe've seen incidents where it's the LOH that fails to grow, in those cases it's been our own code trying to allocate.\r\n\r\nThis reproduces pretty rarely (on the order of once a month or so, though we're concerned it could happen more frequently under higher load), unfortunately, as it's sensitive to GC and request timing.   It took us a few months to come to this conclusion, in part because we didn't have an easy repro to test hypotheses - as noted in the issue, we ended up using Perfview to find where appropriately sized pins were happening and then interrogating the source.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1256276616/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-23T14:19:11Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24169760430",
        "type": "IssueCommentEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "created",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675385778,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg1Nzc4",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/area-System.Net.Security",
                        "name": "area-System.Net.Security",
                        "color": "d4c5f9",
                        "default": false,
                        "description": null
                    },
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    },
                    {
                        "id": 1679235946,
                        "node_id": "MDU6TGFiZWwxNjc5MjM1OTQ2",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/untriaged",
                        "name": "untriaged",
                        "color": "fbca04",
                        "default": false,
                        "description": "New issue has not been triaged by the area owner"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 2,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            },
            "comment": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429",
                "html_url": "https://github.com/dotnet/runtime/issues/76029#issuecomment-1255373429",
                "issue_url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "id": 1255373429,
                "node_id": "IC_kwDODI9FZc5K03p1",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "created_at": "2022-09-22T18:04:59Z",
                "updated_at": "2022-09-22T18:04:59Z",
                "author_association": "NONE",
                "body": "> There shouldn't be any long-lived pinning happening on other OSes. This is inherent to the Windows model for overlapped I/O, where the buffers are supplied to the receive/read calls performing the I/O; on Linux/macOS/etc., a buffer is only supplied under the covers once the implementation is notified data is available. I realize this isn't the intent of your issue, but if you have evidence of this happening anywhere other than Windows, I'd be interested in seeing it.\r\n\r\nAh, this is good to know - I assumed other OS's were similar, but if that is incorrect then there is no evidence this can happen on other OS's.  I'll update the issue accordingly.\r\n\r\n> Are these SslStreams in your control, or are they underlying a component like HttpClient you don't own? You might try using zero-byte reads, e.g. first perform a read with `ReadOnlySpan/Memory<byte>.Empty`, and then only issue the actual read when you know data is available. That should avoid the pinning.\r\n\r\nTechnically we don't control the underlying component, but enough of the reads are simple passthroughs that this might also be a viable mitigation.  Given the way our app is structure it might be a bit painful to apply to everything that matters, but that's our problem not .NET's.\r\n\r\nJust to be clear, you're suggesting we switch:\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nvar foo = await stream.ReadAsync(mem, token);\r\n// use foo\r\n```\r\n\r\nwith\r\n\r\n```csharp\r\n// stream is some Stream\r\n// mem is some Memory<byte>\r\n// token is some CancellationToken\r\nawait stream.ReadAsync(Memory<byte>.Empty, someCancellationToken); \r\nvar foo = await stream.ReadAsync(someMemory, someCancellationToken);\r\n// use foo\r\n```",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/comments/1255373429/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "performed_via_github_app": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T18:04:59Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "24168847483",
        "type": "IssuesEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 210716005,
            "name": "dotnet/runtime",
            "url": "https://api.github.com/repos/dotnet/runtime"
        },
        "payload": {
            "action": "opened",
            "issue": {
                "url": "https://api.github.com/repos/dotnet/runtime/issues/76029",
                "repository_url": "https://api.github.com/repos/dotnet/runtime",
                "labels_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/labels{/name}",
                "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/comments",
                "events_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/events",
                "html_url": "https://github.com/dotnet/runtime/issues/76029",
                "id": 1382772451,
                "node_id": "I_kwDODI9FZc5Sa27j",
                "number": 76029,
                "title": "Out Of Memory From Pinned byte[] used in SslStream",
                "user": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "labels": [
                    {
                        "id": 1675386195,
                        "node_id": "MDU6TGFiZWwxNjc1Mzg2MTk1",
                        "url": "https://api.github.com/repos/dotnet/runtime/labels/tenet-performance",
                        "name": "tenet-performance",
                        "color": "c2e0c6",
                        "default": false,
                        "description": "Performance related issue"
                    }
                ],
                "state": "open",
                "locked": false,
                "assignee": null,
                "assignees": [],
                "milestone": null,
                "comments": 0,
                "created_at": "2022-09-22T17:17:52Z",
                "updated_at": "2022-09-22T17:17:52Z",
                "closed_at": null,
                "author_association": "NONE",
                "active_lock_reason": null,
                "body": "### Description\r\n\r\nA [rented `byte[]` in `SslStream`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L1217) ends up pinned for I/O, contributing to `OutOfMemoryException`s under high memory pressure scenarios.\r\n\r\nThe scenario we've encountered is:\r\n 1. Our application dedicates ~50% of its heap to a cache\r\n    * Over time most of this ends up in Gen2, but at any point in time some of it is in Gen1 and Gen0.\r\n    * We run with a hard memory limit imposed by a Job.\r\n 2. The application is also handling a lot of http requests, with underlying `SslStream`s.\r\n 3. As part of handling these requests some large object heap (LOH) and pinned object heap (POH) allocations are sometimes needed.\r\n    * Most of the POH allocations actually come from Kestrel code.\r\n 4. Occasionally a LOH or POH allocation triggers a GC, but fails to free up enough space for the allocation in the existing heap and so the GC attempts to reclaim space from the ephemeral segment to grow the heap.\r\n 5. Despite the ephemeral segments being mostly free space, this **fails** because of pinned arrays obtained in that `ResetReadBuffer()` method.\r\n    * More precisely, the ephemeral segments are shrunk as far as the pins allow but enough space is not freed up.\r\n 6. Runtime raises an `OutOfMemoryException`, and our application crashes.\r\n\r\nI waffled between whether this is a bug or a performance concern.  Everything is technically functioning correctly, so I settled on performance concern.\r\n\r\n### Configuration\r\n\r\nThis is observed under various .NET 6 point releases, running under Windows, on Intel x64 hardware.  We are using the concurrent server GC.\r\n\r\nThis appears to be possible under all OS & hardware combinations, but we have not reproduced it elsewhere.\r\n\r\n### Regression?\r\n\r\nThis is **not** a regression, however recent versions of .NET introduce the pinned object heap (POH) which offers a mitigation.\r\n\r\n### Data\r\n\r\nWe diagnosed this by looking at crash dumps and observing that pinned `byte[]`s with 32,768 elements were always at the end of the ephemeral segments, and then using Perfview to try and catch pinning in the act.  That led us to `SslStream`, and then a close reading of the source found an appropriately sized array (recall that `ArrayPool` rounds up to nearest power of 2, so [`ReadBufferSize == 4_096 * 4 + FrameOverhead == 16_448`](https://github.com/dotnet/runtime/blob/531f715f281e7a6456375635c02b6dd301d95996/src/libraries/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs#L44) will get a `byte[]`s with 32,768 elements).\r\n\r\n### Analysis\r\n\r\nWhile our particular issue appears to be caused by that array, in theory any `byte[]` (which is not on the POH) used for I/O in `SslStream` could also cause it.\r\n\r\nStarting in .NET 5.0 the POH is available, which enables keeping pins out of the ephemeral segments.  Kestrel has adopted the POH (via its [`PinnedBlockMemoryPool`](https://github.com/dotnet/aspnetcore/blob/main/src/Shared/Buffers.MemoryPool/PinnedBlockMemoryPool.cs)) for much of it I/O, which neatly avoids this problem (while also providing some performance benefits, potentially).\r\n\r\nI'm not familiar enough with `SslStream`'s implementation to say whether adopting a similar approach as a simple drop in is viable, so I have not created a PR.",
                "reactions": {
                    "url": "https://api.github.com/repos/dotnet/runtime/issues/76029/reactions",
                    "total_count": 0,
                    "+1": 0,
                    "-1": 0,
                    "laugh": 0,
                    "hooray": 0,
                    "confused": 0,
                    "heart": 0,
                    "rocket": 0,
                    "eyes": 0
                },
                "timeline_url": "https://api.github.com/repos/dotnet/runtime/issues/76029/timeline",
                "performed_via_github_app": null,
                "state_reason": null
            }
        },
        "public": true,
        "created_at": "2022-09-22T17:17:52Z",
        "org": {
            "id": 9141961,
            "login": "dotnet",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/dotnet",
            "avatar_url": "https://avatars.githubusercontent.com/u/9141961?"
        }
    },
    {
        "id": "23569388199",
        "type": "ForkEvent",
        "actor": {
            "id": 1219467,
            "login": "kevin-montrose",
            "display_login": "kevin-montrose",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kevin-montrose",
            "avatar_url": "https://avatars.githubusercontent.com/u/1219467?"
        },
        "repo": {
            "id": 156260788,
            "name": "Azure/azure-cosmos-dotnet-v3",
            "url": "https://api.github.com/repos/Azure/azure-cosmos-dotnet-v3"
        },
        "payload": {
            "forkee": {
                "id": 527664030,
                "node_id": "R_kgDOH3ODng",
                "name": "azure-cosmos-dotnet-v3",
                "full_name": "kevin-montrose/azure-cosmos-dotnet-v3",
                "private": false,
                "owner": {
                    "login": "kevin-montrose",
                    "id": 1219467,
                    "node_id": "MDQ6VXNlcjEyMTk0Njc=",
                    "avatar_url": "https://avatars.githubusercontent.com/u/1219467?v=4",
                    "gravatar_id": "",
                    "url": "https://api.github.com/users/kevin-montrose",
                    "html_url": "https://github.com/kevin-montrose",
                    "followers_url": "https://api.github.com/users/kevin-montrose/followers",
                    "following_url": "https://api.github.com/users/kevin-montrose/following{/other_user}",
                    "gists_url": "https://api.github.com/users/kevin-montrose/gists{/gist_id}",
                    "starred_url": "https://api.github.com/users/kevin-montrose/starred{/owner}{/repo}",
                    "subscriptions_url": "https://api.github.com/users/kevin-montrose/subscriptions",
                    "organizations_url": "https://api.github.com/users/kevin-montrose/orgs",
                    "repos_url": "https://api.github.com/users/kevin-montrose/repos",
                    "events_url": "https://api.github.com/users/kevin-montrose/events{/privacy}",
                    "received_events_url": "https://api.github.com/users/kevin-montrose/received_events",
                    "type": "User",
                    "site_admin": false
                },
                "html_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "description": ".NET SDK for Azure Cosmos DB for the core SQL API",
                "fork": true,
                "url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3",
                "forks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/forks",
                "keys_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/keys{/key_id}",
                "collaborators_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/collaborators{/collaborator}",
                "teams_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/teams",
                "hooks_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/hooks",
                "issue_events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/events{/number}",
                "events_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/events",
                "assignees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/assignees{/user}",
                "branches_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/branches{/branch}",
                "tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/tags",
                "blobs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/blobs{/sha}",
                "git_tags_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/tags{/sha}",
                "git_refs_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/refs{/sha}",
                "trees_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/trees{/sha}",
                "statuses_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/statuses/{sha}",
                "languages_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/languages",
                "stargazers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/stargazers",
                "contributors_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contributors",
                "subscribers_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscribers",
                "subscription_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/subscription",
                "commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/commits{/sha}",
                "git_commits_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/git/commits{/sha}",
                "comments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/comments{/number}",
                "issue_comment_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues/comments{/number}",
                "contents_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/contents/{+path}",
                "compare_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/compare/{base}...{head}",
                "merges_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/merges",
                "archive_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/{archive_format}{/ref}",
                "downloads_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/downloads",
                "issues_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/issues{/number}",
                "pulls_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/pulls{/number}",
                "milestones_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/milestones{/number}",
                "notifications_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/notifications{?since,all,participating}",
                "labels_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/labels{/name}",
                "releases_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/releases{/id}",
                "deployments_url": "https://api.github.com/repos/kevin-montrose/azure-cosmos-dotnet-v3/deployments",
                "created_at": "2022-08-22T17:21:38Z",
                "updated_at": "2022-08-22T11:17:41Z",
                "pushed_at": "2022-08-22T11:27:07Z",
                "git_url": "git://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "ssh_url": "git@github.com:kevin-montrose/azure-cosmos-dotnet-v3.git",
                "clone_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3.git",
                "svn_url": "https://github.com/kevin-montrose/azure-cosmos-dotnet-v3",
                "homepage": null,
                "size": 147074,
                "stargazers_count": 0,
                "watchers_count": 0,
                "language": null,
                "has_issues": false,
                "has_projects": true,
                "has_downloads": true,
                "has_wiki": true,
                "has_pages": false,
                "forks_count": 0,
                "mirror_url": null,
                "archived": false,
                "disabled": false,
                "open_issues_count": 0,
                "license": null,
                "allow_forking": true,
                "is_template": false,
                "web_commit_signoff_required": false,
                "topics": [],
                "visibility": "public",
                "forks": 0,
                "open_issues": 0,
                "watchers": 0,
                "default_branch": "main",
                "public": true
            }
        },
        "public": true,
        "created_at": "2022-08-22T17:21:38Z",
        "org": {
            "id": 6844498,
            "login": "Azure",
            "gravatar_id": "",
            "url": "https://api.github.com/orgs/Azure",
            "avatar_url": "https://avatars.githubusercontent.com/u/6844498?"
        }
    }
]